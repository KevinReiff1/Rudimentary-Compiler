#pragma once
#include <unordered_map>
#include <utility>

#include "Parser.h"
#include "SymbolTable.h"

class CodeBuffer {
    SymbolTable symbol_table;
    std::vector<uint8_t> code;
    uint8_t position = 0;
    uint8_t heap = 0xFF;
    std::map<uint16_t, std::vector<uint8_t> > temp_addresses;

public:
    CodeBuffer() : code(256, 0) {
    }

    /**
     * Emits a byte to the code buffer.
     *
     * This function writes a single byte to the code buffer at the current
     * position and advances the position pointer. If the position exceeds
     * the buffer size of 256 bytes, an exception is thrown, indicating that
     * the code length limit has been exceeded.
     *
     * @param byte The byte value to emit into the code buffer.
     * @throws std::runtime_error if the number of generated bytes exceeds 256.
     */
    void emit(uint8_t byte) {
        if (position >= 256)
            throw std::runtime_error("Code exceeds 256 bytes");

        code[position++] = byte;
    }

    /**
     * Emits an operation code and its operand to the code buffer.
     *
     * This function writes a pair of bytes to the code buffer. The first byte
     * represents the operation code (op), followed by the operand (operand).
     * Each byte is emitted sequentially to the buffer using the `emit(uint8_t byte)` method.
     * If the buffer size of 256 bytes is exceeded, an exception is thrown.
     *
     * @param op The operation code to be emitted to the code buffer.
     * @param operand The operand associated with the operation code to be emitted into the buffer.
     * @throws std::runtime_error if the number of generated bytes exceeds 256.
     */
    void emit(uint8_t op, uint8_t operand) {
        emit(op);
        emit(operand);
    }

    /**
     * Emits an operation code followed by a 16-bit address to the code buffer
     * while tracking temporary address references for backpatching.
     *
     * This function first emits the operation code to the code buffer. Then, it adds
     * the current position of the emitted instruction to the list of positions
     * associated with the given address in the temporary address map. Finally, it
     * emits the 16-bit address in little-endian order (lower byte first, followed by
     * the higher byte).
     *
     * @param op The operation code to be emitted.
     * @param address The 16-bit address to be emitted and tracked for backpatching.
     * @throws std::runtime_error if the number of generated bytes exceeds the buffer size of 256 bytes.
     */
    void emit_with_temp_address(uint8_t op, uint16_t address) {
        emit(op);
        temp_addresses[address].push_back(position);
        emit(address & 0xFF); // Little-endian
        emit((address >> 8) & 0xFF);
    }

    /**
     * Adds a string variable to the code buffer.
     *
     * This function stores the given string on heap within code buffer
     * starting at the current heap pointer. A null terminator ('\0') is added at the
     * end of the string. After storing the string, the heap pointer is decreased, and
     * the starting position of the string in the buffer is returned.
     *
     * @param name The string value to be stored in the code buffer.
     * @return The starting position of the string in the code buffer.
     */
    uint8_t add_string_variable(const std::string &name) {
        code[heap--] = '\0';
        for (auto pos = name.rbegin(); pos != name.rend(); ++pos) {
            code[heap--] = *pos;
        }

        return heap + 1;
    }

    /**
     * Resolves temporary address placeholders in the code buffer.
     *
     * This function updates the code buffer with final positions for temporary
     * addresses that were previously marked during code generation. It increments
     * the current position pointer and iterates over each entry in the `temp_addresses`
     * map. For each entry, it updates the code buffer positions corresponding to the
     * offsets stored in the map with the current position value. After backpatching
     * the offsets for a specific address, the position pointer is incremented further
     * to account for additional space consumed by the new addresses.
     *
     * The purpose of this function is to ensure that previously unresolved addresses
     * in the generated code are filled with correct values before finalizing the code.
     */
    void backpatch() {
        ++position;

        for (auto &[address, offsets]: temp_addresses) {
            for (auto offset: offsets) {
                code[offset] = position;
            }

            position += 2;
        }
    }

    /**
     * Retrieves the current state of the code buffer.
     *
     * This function provides a read-only vector containing all bytes currently
     * stored in the code buffer. The returned vector represents the complete
     * sequence of emitted instructions and data, enabling inspection or further
     * processing of the generated code.
     *
     * @return A vector of bytes representing the current contents of the code buffer.
     */
    [[nodiscard]] std::vector<uint8_t> getCode() const { return code; }
    [[nodiscard]] size_t getPosition() const { return position; }
};

class CodeGen final {
    SymbolTable symbol_table;
    CodeBuffer buffer;

public:
    CodeGen() = default;

    ~CodeGen() = default;

    /**
     * Generates machine code for the provided abstract syntax tree (AST) node.
     *
     * This function processes the given AST node by invoking the corresponding
     * visitor function and subsequently resolves all pending backpatches in
     * the code buffer to finalize the generated code.
     *
     * @param node The abstract syntax tree node to be processed for code generation.
     */
    void generate(const Node &node) {
        visit(node);
        buffer.backpatch();
    }

    /**
     * Prints the contents of the internal code buffer in a formatted hexadecimal representation.
     *
     * This method retrieves the contents of the code buffer, formats each byte into a two-character
     * uppercase hexadecimal string, and prints the result to the standard output. The output is
     * formatted into lines of up to 16 values, separated by spaces.
     */
    void print() const {
        auto code = buffer.getCode();
        int i = 0;
        for (const auto val: code) {
            i++;

            std::stringstream ss;

            ss << std::hex
                    << std::uppercase
                    << std::setfill('0')
                    << std::setw(2) // Ensure at least 2 characters
                    << static_cast<int>(val);

            std::cout << ss.str() << ' ';
            if (i == 16) {
                i = 0;
                std::cout << std::endl;
            }
        }

        std::cout << std::endl;
    }

    /**
     * Handles the declaration of a variable by generating the corresponding
     * machine code instructions and updating the symbol table.
     *
     * This function adds the declared variable to the symbol table, initializes
     * its value to 0, and emits the instructions to achieve this in the code buffer.
     *
     * @param node The abstract syntax tree node representing the variable
     *             declaration. It should contain the identifier node as the first
     *             child and the name node as the second child.
     */
    void handle_var_decl(const Node &node) {
        const auto id_node = node.get_children().front();
        const auto name = node.get_children()[1];
        symbol_table.add_symbol(name.get_value(), node_to_data_type(id_node.get_value()),
                                id_node.get_line());
        // Initialize to 0: LDA #00; STA [temp]
        buffer.emit(0xA9, 0x00);
        auto symbol = symbol_table.findSymbol(name.get_value());
        buffer.emit_with_temp_address(0x8D, symbol->temp_address);
    }

    /**
     * Handles the assignment operations in the intermediate representation.
     *
     * This function processes an assignment node by determining the type of the
     * variable being assigned (integer, boolean, or string), and generates the
     * appropriate machine code instructions to store the assigned value in the
     * temporary address of the variable. For integer and boolean types, the value
     * is directly encoded and emitted. For string types, the string is stored as
     * a variable, and its address is used in the generated code.
     *
     * @param node The assignment node from the abstract syntax tree. It contains
     *             the variable being assigned and the value to assign.
     * @throws std::runtime_error if symbol resolution fails or input is invalid.
     */
    void handle_assign(const Node &node) {
        auto &children = node.get_children();
        auto *symbol = symbol_table.findSymbol(children.front().get_value());

        if (symbol->type == DataType::Int) {
            auto value = static_cast<uint8_t>(std::stoi(children.back().get_value()));
            buffer.emit(0xA9, value);
            buffer.emit_with_temp_address(0x8D, symbol->temp_address);
        } else if (symbol->type == DataType::Boolean) {
            uint8_t value = children.back().get_value() == "true" ? 1 : 0;
            buffer.emit(0xA9, value);
            buffer.emit_with_temp_address(0x8D, symbol->temp_address);
        } else {
            auto pos = buffer.add_string_variable(children.back().get_value());
            buffer.emit(0xA9, pos);
            buffer.emit_with_temp_address(0x8D, symbol->temp_address);
        }
    }

    /**
     * Generates code to handle the print operation for a given node in the AST.
     *
     * This method processes the specified node to determine the type of the value
     * to be printed and emits the appropriate machine code instructions. Depending
     * on the node type, it retrieves the symbol information and emits system-specific
     * calls to enable printing of different data types such as integers, strings,
     * or booleans.
     *
     * @param node The AST node to handle for the print operation. This node
     *             contains the value and type information needed for code generation.
     */
    void handle_print(const Node &node) {
        const auto &children = node.get_children();
        auto &item = children.front();
        switch (item.get_node_type()) {
            case NodeType::ID:
            case NodeType::INT_EXPRESSION:
            case NodeType::STRING_EXPRESSION:
            case NodeType::BOOLEAN_EXPRESSION:
                break;
        }
        auto symbol = symbol_table.findSymbol(item.get_value());
        buffer.emit_with_temp_address(0xAC, symbol->temp_address); // LDY var
        buffer.emit(0xA2, symbol->type == DataType::String ? 0x02 : 0x01); // LDX #0x
        buffer.emit(0xFF); // SYS
    }

    void handle_if(const Node &node) {
        // Compare variables (simplified)
        //std::string lhs = node->left->left->value;
        //std::string rhs = node->left->right->value;

        //buffer.emit(0xAE, symtab.getAddress(lhs)); // LDX lhs
        //buffer.emit(0xEC, symtab.getAddress(rhs)); // CPX rhs
        //buffer.emit(0xD0); // BNE operand (temp)
        size_t patch_addr = buffer.getPosition();
        //buffer.emit(0x00); // Placeholder
        //backpatches["IF"] = patch_addr;

        //traverse(node->right); // Generate 'then' block
    }

    // Generate code for if statement
    /*void generateIf(const Node &node) {
        // Condition: Assume form (var == value)
        Symbol *sym = findSymbol(node->children[0]->children[0]->value, node->children[0]->children[0]->scope);
        int value = std::stoi(node->children[0]->children[1]->value);
        emit({0xEC, static_cast<uint8_t>(sym->offset & 0xFF), static_cast<uint8_t>(sym->offset >> 8)});
        emit({0xD0, 0x00}); // Placeholder for jump
        int jumpAddr = machineCode.size() - 1;
        // Body
        for (const auto *child: node->children[1]->children) {
            generateNode(ASTchild);
        }
        jumpBackpatch.push_back({jumpAddr, machineCode.size() - jumpAddr});
    }*/

    // Generate code for while loop
    /* void generateWhile(const ASTNode *node) {
         int loopStart = machineCode.size();
         // Condition: Assume form (var != value)
         Symbol *sym = findSymbol(node->children[0]->children[0]->value, node->children[0]->children[0]->scope);
         int value = std::stoi(node->children[0]->children[1]->value);
         emit({
             0xAD, static_cast<uint8_t>(sym->offset & 0xFF), static_cast<uint8_t>(sym->offset >> 8), 0x8D, 0x54, 0x00
         });
         emit({0xA9, static_cast<uint8_t>(value), 0x8D, 0x53, 0x00});
         emit({0xAE, 0x54, 0x00, 0xEC, 0x53, 0x00});
         emit({0xD0, 0x00}); // Placeholder for jump
         int jumpAddr = machineCode.size() - 1;
         // Body
         for (const auto *child: node->children[1]->children) {
             generateNode(child);
         }
         // Jump back to start
         int distance = loopStart - machineCode.size() - 2;
         emit({0xD0, static_cast<uint8_t>(distance & 0xFF)});
         jumpBackpatch.push_back({jumpAddr, machineCode.size() - jumpAddr});
     }*/

    /*void resolveBackpatches() {
        // Example: Calculate jump distance for IF
        for (auto &[label, addr]: backpatches) {
            // Simplified: Assume 6 bytes to skip (as in document example)
            buffer.backpatch(addr, 0x06);
        }
    }*/

    [[nodiscard]] std::vector<uint8_t> getMachineCode() const {
        return buffer.getCode();
    }

    void visit(const Node &node) {
        auto children = node.get_children();

        switch (node.get_node_type()) {
            case NodeType::BLOCK: {
                symbol_table.enter_scope();
                for (auto &child: children) {
                    visit(child);
                }
                symbol_table.exit_scope();
                break;
            }
            case NodeType::VARIABLE_DECLARATION: {
                handle_var_decl(node);

                break;
            }
            case NodeType::ASSIGNMENT_STATEMENT:
                handle_assign(node);
                break;
            case NodeType::IF_STATEMENT:
                handle_if(node);
                break;
            case NodeType::WHILE_STATEMENT:
                //generate_while(node);
                break;
            case NodeType::PRINT_STATEMENT: {
                handle_print(node);
                auto val = children.front().get_value();
                break;
            }
        }
    }
};
